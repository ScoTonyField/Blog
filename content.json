{"pages":[],"posts":[{"title":"React -- node_modules&#x2F;canvans pig-config no found","text":"问题描述按照react的官方文档，npm &gt;= 5.2的版本可以直接用npx create-react-app my-app代替npm install create-react-app &amp;&amp; create-react-app my-app 一开始安装到node_modules/canvas时报错显示pkg-config no found 解决方法：brew install pkg-config 但是随之而来有了新的问题（如下图）：问题显示没有能够找到pangocairo.pc在目录中。开始认为是cairo包没有安装的问题，在进行安装后发现还是继续产生相同的报错。 随后在文章中发现该文件是属于pango包。 对pango包进行下载： 再次尝试npx create-react-app my-app","link":"/blog/2021/03/06/react_problem/"},{"title":"Leetcode - 459 - KMP求解重复子串组成","text":"字符串匹配 - Pattern Matching 定义：给定两个字符串，T(text) 和 P(pattern)，字符串匹配的目标就是从T中找到和P一样的子串。其广泛引用于文本编辑、搜索引擎、生物搜索等领域 Navie pattern matching Boyer-Moore pattern matching Knuth-Morris-Pratt pattern matching Navie pattern matching 从左往右每个字符进行对应检查，直到找到匹配的子串，或者 尝试了所有检查 12345678910111213141516-- Pseudo code of NM --NaiveMatching(T,P): | Input: T的长度n, P的长度m | Output: T中匹配子串的起始索引 | 如果没有找到匹配的子串, 则返回-1 | | for all i=0..n-m do| | j=0 // 从左往右进行检查 | | while j&lt;m and T[i+j]=P[j] do // 从选定的T的第i个字符开始匹配检查| | | j=j+1 | | | if j=m then| | | return i // 返回匹配到的子串索引| | | end if| | end while| end for| return -1 // 没有找到匹配子串 时间复杂度：O(n*m) 存在某些很糟糕的情况： T: aaaaaaa..ah P: aaah 该种情况可能多发生于DNA序列中 提升：跳跃式匹配可以将时间复杂度降低到O(n) Boyer-Moore matching =&gt; 从左往右迭代，从尾往前配对BM算法主要是用了两种思想： Looking-glass: 每次在P和T的子串进行对比时，从右往左进行配对 Character-jump: 当出现P和T中不匹配的字符时，T[i] = c 如果P中拥有该字符，则将P中最后出现的字符的索引跳跃至不匹配的位置 如果P中没有该字符，则P的首位字符跳跃到T[i+1]处进行下一次匹配(Big Jump) 图示： 对于最后出现字符，我们需要构造一个数组进行存储： Last-occurrence function L: 给定T中的字母表sigma, L(c)记录了字母表中每一个字母在P中出现的最末位的索引 -1表示P中没有改字母 L可以在O(n+m)的时间复杂度内进行构造 1234567891011121314151617181920BoyerMooreMatch(T,P,Σ): | Input: T的长度n, P的长度m, 字母表 Σ| Output: T中匹配子串的起始索引 | 如果没有找到匹配的子串, 则返回-1 | | L=lastOccurenceFunction(P,Σ)| i=m-1, j=m-1 // 从P末尾开始配对检查 | repeat| | if T[i]=P[j] then| | | if j=0 then| | | return i // 返回配对完成的子串索引| | | else| | | i=i-1, j=j-1 | | | end if| | else // character-jump | | | i=i+m-min(j,1+L[T[i]]) // 关键跳跃代码| | | j=m-1 | | end if| until i≥n| return -1 // 返回没有匹配 针对跳跃的情况，如下图所示： 情况1: 当前不匹配的T中的字符在L(c)中，出现在当前配对位置的后方，如果直接进行相等位置进行跳跃会造成回退的问题，所以只用跳跃一位即可 情况2: 当前不配的T中的字符在L(c)中，出现在当前配对位置的前方(意味着还没有进行配对上)，这种情况可以直接进行定点跳跃 时间复杂度O(nm+s) - s：字母表的长度 最差情况： T：aaaaa…aa P：baaaaa 通常情况下，BM算法要优于Naive Matching Knuth-Morris-Pratt (KMP)相对于前两种字符串匹配算法，KMP算法在配对上是采用从头往尾进行配对的形式，但是跳跃的方式比navie方式更加智能。在KMP算法中需要用到字符串前缀(prefix)和字符串后缀(suffix)的知识点，当出现不匹配的字符时，KMP考虑了以下的问题： 我们该如何进行最大跳跃或者换位的方法，从而避免冗余重复的匹配？ P[0…j]中的最大前缀也是P[1…j]的后缀 这种跳跃方法不仅避免了按位迭代的冗余匹配还防止进行完全跳跃的缺漏(直接将P的头索引跳跃到不匹配的位置上) 为什么选取P[1…j]是因为如果同时选用相同的P[0…j]，会发现完整的字符串永远是最大的，所以头索引往后移动一位，不往前移动也是因为考虑的是后缀而不是前缀。 根据上述的情况，KMP引入了Failure function F(j)来找到P中不同位置起始的最大前缀长度 ，即跳跃长度。 12345678910111213141516171819202122232425262728293031323334353637383940414243KMPMatch(T,P): | Input: T的长度n, P的长度m| Output: T中匹配子串的起始索引 | 如果没有找到匹配的子串, 则返回-1 | | F=failureFunction(P) | i=0, j=0 // 从头往尾部进行匹配 | while i&lt;n do| | if T[i]=P[j] then| | | if j=m-1 then| | | return i-j // 返回找到的子串索引 | | | else| | | i=i+1, j=j+1 | | | end if| | else // P[j]处出现不匹配| | | if j&gt;0 then| | | j=F[j-1] // 进行跳跃| | | else| | | i=i+1 | | | end if| | end if| end while| return -1 // 没有找到匹配 failureFunction(P): | Input P的长度m | Output failure function | | F[0]=0 // F[0]永远为0 | j=1, len=0 | while j&lt;m do| | if P[j]=P[len] then| | len=len+1 // 匹配到了(len+1)个字符 | | F[j]=len // P[0..len-1] = P[len-1..j] | | j=j+1 | | else if len&gt;0 then // 不匹配且len &gt; 0? | | len=F[len-1] // → 用前一个F值| | else // 不匹配且len = 0? | | F[j]=0 // → no prefix of P[0..j] is also suffix of P[1..j] | | j=j+1| | end if| end while| return F Failure function可以在O(m)的时间复杂度内得到 KMP的时间复杂度为O(n+m) BM v.s. KMP BM 在字母表很大时效果会更好 KMP 在字母表很小时效果会更好 Leetcode - 459Leetcode-459 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * @param {string} s * @return {boolean} */ var repeatedSubstringPattern = function(s) { return KMP(s.repeat(2).substring(1, 2*s.length-1), s) == -1 ? false : true; //神操作};/** * @param {string} p * @return {array} */var failureFunction = function(p) { let F = new Array(p.length); F[0] = 0; let j = 1; let len = 0; while (j &lt; p.length) { if (p[j] == p[len]) { len++; F[j] = len; j++; } else if (len &gt; 0) { len = F[len-1]; } else { F[j] = 0; j++; } } return F;};/** * @param {string} t * @param {string} p * @return {number} */var KMP = function(t, p) { const F = failureFunction(p); // console.log(F); let i = 0; let j = 0; while (i &lt; t.length) { if (t[i] == p[j]) { if (j == p.length - 1 ) { return i-j; } else { i++; j++; } } else { if (j &gt; 0) { j = F[j-1]; } else { i++; } } } return -1;}","link":"/blog/2021/03/19/20210319-Leetcode---459---KMP%E6%B1%82%E8%A7%A3%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2%E7%BB%84%E6%88%90/"}],"tags":[{"name":"React","slug":"React","link":"/blog/tags/React/"},{"name":"Leetcode","slug":"Leetcode","link":"/blog/tags/Leetcode/"}],"categories":[]}